use axum::{
    extract::State, 
    routing::post, 
    Json, Router,
};
use serde::{Deserialize, Serialize};
use crate::{
    api::{error::ApiResult, AppState}, auth::types::AuthUser, models::{calendar_event::CalendarEvent, recurring_event::RecurringEvent, recurring_event_group::NewRecurringEventGroup}
};

/// The struct for a text request.
#[derive(Deserialize)]
struct TextToEventRequest {
    text: String,
}

/// Normal + recurring events generated by the AI (optionally, a group for the recurring events if deemed sensible).
#[derive(Serialize)]
pub struct GeneratedEvents {
    events: Vec<CalendarEvent>,
    recurring_events: Vec<RecurringEvent>,
    recurring_event_group: Option<NewRecurringEventGroup>
}

/// Build the router for AI event routes.
pub(super) fn router() -> Router<AppState> {
    Router::new()
        .route("/text", post(process_text_to_events))
        .route("/audio", post(process_audio_to_events))
        .route("/image", post(process_image_to_events))
}

async fn process_text_to_events(
    State(app_state): State<AppState>,
    user: AuthUser,
    Json(payload): Json<TextToEventRequest>,
) -> ApiResult<Json<GeneratedEvents>> {
    // Implementation:
    // 1. Validate input text
    // 2. Call AI service to process text
    // 3. Parse AI response into CalendarEvent
    // 4. Save event to database
    // 5. Return created events

    let response = GeneratedEvents {
        events: vec![],
        recurring_events: vec![],
        recurring_event_group: None
    };
    Ok(Json(response))
}

async fn process_audio_to_events(
    State(app_state): State<AppState>,
    user: AuthUser,
    // ContentLengthLimit(audio_data): ContentLengthLimit<Bytes, { 10 * 1024 * 1024 }>, // 10MB limit
) -> ApiResult<Json<GeneratedEvents>> {
    // Implementation:
    // 1. Validate audio data format/size
    // 2. Call speech-to-text service
    // 3. Call AI service to process transcribed text
    // 4. Parse AI response into CalendarEvent
    // 5. Save event to database
    // 6. Return created events

    let response = GeneratedEvents {
        events: vec![],
        recurring_events: vec![],
        recurring_event_group: None
    };
    Ok(Json(response))
}

async fn process_image_to_events(
    State(app_state): State<AppState>,
    user: AuthUser,
    // ContentLengthLimit(audio_data): ContentLengthLimit<Bytes, { 10 * 1024 * 1024 }>, // 10MB limit
) -> ApiResult<Json<GeneratedEvents>> {
    // Implementation:
    // 1. Validate audio data format/size
    // 2. Call speech-to-text service
    // 3. Call AI service to process transcribed text
    // 4. Parse AI response into CalendarEvent
    // 5. Save event to database
    // 6. Return created events

    let response = GeneratedEvents {
        events: vec![],
        recurring_events: vec![],
        recurring_event_group: None
    };
    Ok(Json(response))
}